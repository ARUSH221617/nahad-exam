"use server";

import { GoogleGenAI, FunctionCallingConfigMode, Type } from "@google/genai";
import prisma from "@/lib/prisma";
import { generateEmbedding } from "@/lib/ai";
import { createClient } from "@/lib/supabase/server";
import { contextualizeQuestion, hybridSearch } from "@/lib/rag";

export async function askQuestion(
  docId: string,
  question: string,
  history: { role: string; parts: string[] }[]
) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  const userId = user?.id ?? "anonymous";

  // 1. Retrieve context
  const doc = await prisma.document.findUnique({
    where: { id: docId },
  });

  if (!doc) throw new Error("Document not found");

  // --- Advanced RAG: Contextualize Question ---
  const standaloneQuestion = await contextualizeQuestion(question, history);
  console.log(`Contextualized Question: "${standaloneQuestion}" (Original: "${question}")`);

  // Generate embedding for the standalone question
  const questionEmbedding = await generateEmbedding(standaloneQuestion);

  // --- Advanced RAG: Hybrid Search ---
  const chunks = await hybridSearch(docId, standaloneQuestion, questionEmbedding);

  const context = chunks.map((c) => c.content).join("\n\n");
  const references = chunks.map((c, i) => `Source ${i+1}: ${c.content.substring(0, 50)}...`);

  // 2. Generate Answer with Function Calling
  const apiKey = process.env.GOOGLE_GENERATIVE_AI_API_KEY;
  if (!apiKey) {
    return {
      answer: "Error: API Key not found.",
      references: [],
    };
  }

  const ai = new GoogleGenAI({ apiKey });
  const model = "gemini-2.5-flash-lite"; // Supports function calling well

  // Define the tool
  const saveExamTool = {
    name: "save_exam_result",
    description: "Saves the question and answer to the database history when a valid question is answered.",
    parameters: {
      type: Type.OBJECT,
      properties: {
        question: { type: Type.STRING, description: "The question asked by the user" },
        answer: { type: Type.STRING, description: "The answer generated by the model" },
      },
      required: ["question", "answer"],
    },
  };

  const config = {
    tools: [
      {
        functionDeclarations: [saveExamTool],
      },
    ],
    toolConfig: {
      functionCallingConfig: {
        mode: FunctionCallingConfigMode.AUTO,
      },
    },
  };

  // Improved Prompt for "Advanced RAG"
  // Encourages reasoning and strict adherence to context.
  const prompt = `You are an expert in Nahad exams.
    Context:
    ${context}

    User Question: ${standaloneQuestion}

    Instructions:
    1. Read the provided context carefully.
    2. Think step-by-step: Does the context contain the answer to the User Question?
    3. If yes, formulate a clear, comprehensive answer in Persian (RTL) using Markdown.
    4. If the context does not contain the answer, state "پاسخ در متن یافت نشد" (Answer not found in text) and do NOT call the save tool.
    5. If you successfully answered the question using the context, you MUST call the "save_exam_result" tool to save it.
    6. If the user input is not a question (e.g. greeting), just reply politely in Persian and do not call the tool.

    Begin!`;

  const contents = [
    ...history.map(h => ({ role: h.role === 'user' ? 'user' : 'model', parts: [{ text: h.parts.join('') }] })),
    {
      role: "user",
      parts: [
        {
          text: prompt,
        },
      ],
    },
  ];

  const result = await ai.models.generateContent({
    model,
    config,
    contents,
  });

  let answerText = "";

  // Handle function calls
  // @ts-ignore
  const functionCalls = result.functionCalls;

  if (functionCalls && functionCalls.length > 0) {
      for (const call of functionCalls) {
          if (call.name === "save_exam_result") {
              const args = call.args as { question: string, answer: string };
              console.log("Saving exam result via tool call:", args);

              // Execute the saving logic
              await prisma.exam.create({
                  data: {
                      question: args.question,
                      answer: args.answer,
                      references: JSON.stringify(references),
                      documentId: docId,
                      userId: userId,
                  }
              });

              answerText = args.answer;
          }
      }
  }

  if (result.text) {
      answerText = result.text;
  }

  if (!answerText && functionCalls && functionCalls.length > 0) {
      const args = functionCalls[0].args as { answer: string };
      answerText = args.answer;
  }

  return { answer: answerText, references };
}
